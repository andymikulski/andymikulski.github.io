---
layout: dev-post
title: "nES6: First Steps"
permalink: /dev/multines/intro
blog: dev
project: multines
projectName: MultiNES
description: "The story so far behind nES6 and its path to MultiNES."
tech:
  - node
  - socket.io
  - nes6
thumbnail: http://i.imgur.com/n5OLVfY.png
# github: https://github.com/andymikulski/mnes
---

# Introduction

Some time ago, I had an idea on how I could possibly create a multiplayer NES experience for the web. The idea was pretty basic: simply run the inputs from one player to the other! Packed with my bit of [socket.io](https://socket.io/) from that one chat demo I had put together in a few minutes, I was sure I could get this thing working. And I did! But it was a long path to get there.

Initially, I hoped to simply use someone else's emulator, as I was keen on testing out my multiplayer idea, and not necessarily re-emulating the wheel. Unfortunately, there wasn't an emulator available that offered an API for programattic control. Most packages/library offered "full-scale" solutions, in that they attempted to be an entire application. For instance, [WebNES](https://peteward44.github.io/WebNES/index_app.html) offers UI elements for loading ROMs, adjusting volume, etc.

### Good Artists Copy, Great Artists Fork

I will say here and now: my work stands on the shoulders of giants. Without finding Pete Ward's [WebNES repo](https://github.com/peteward44/webnes), my project would not have gone anywhere. WebNES offered a lot from the start: support for most games, WebGL + shader capability, and save states could painlessly be imported/exported. Having never worked with an emulator before, it was also easy to approach the pure javascript codebase.

<img src="https://imgur.com/NY8MPU7.png" style="max-height: 500px" title="River City Ransom on WebNES" />
<label>WebNES offers support for WebGL shaders which is a nice bonus! Here, a curved CRT filter is applied.</label>

I forked WebNES, and with the intention of a complete overhaul into 'modern' javascript, renamed the project [nES6](https://github.com/andymikulski/nES6/).


### Getting Started

The first step was to get my hands messy and see what things looked like. WebNES was built using grunt, bower, and jQuery - all relics of front-end methods from years past. The starting tasks were fairly simple, though generally time-consuming:

- Switch dependency management from bower to npm/package.json
- Implement ES6 `class`es and remove all the `prototype` business.
  - Some functionality was able to be abstracted, such as the Emitter class used for messaging between components.
- Delete all UI-related code and remove jQuery as a dependency.
  - nES6 doesn't want to handle any of the page UI by design.
- Undo the use of global 'namespaces' (such as `Nes`) and switch to using `import`s.

And the list goes on. It took a bit of time, indeed. Eventually, I managed to get all the pieces connected and it ran! Huzzah! The issue, though, was that the framerate was subpar. Maybe hitting 30 FPS with stuttering. Totally unacceptable.

### Optimizing, or: The Fun Part

At this point, I'd worked on the web for a majority of my professional career, and have handled a few optimizations in my time. I can memoize functions all day, let me tell you. Using `console.time` and seeing a function call drop from `20ms` to `1ms` got me every time. And then I optimized nES6. Seeing and feeling a game become _objectively better_ after optimizing code is an awesome feeling.

After investigating the [Mozilla Firefox](https://www.mozilla.org/en-US/firefox/new/) flamechart, I dug into the code. After learning that the color palatte lookups were eating up cycles, I did what I know best: memoized. I cached the heck out of that color lookup function, I tell you what. 

<img src="https://i.imgur.com/2CEXB1E.jpg" height="420" />
<label>Oh.</label>

Maybe I didn't get it right the first time, but after fixing the cache, average FPS jumped up to acceptable ranges! Unhappy, I kept digging. 

Another issue was garbage collection - tons of `Uint32Array`s created and tossed each frame, for instance. The most curious piece of all this is that WebNES runs just fine in the browser if you [try the demo](https://peteward44.github.io/WebNES/index_app.html). There are a number of potential causes: dependencies have updated, webpack generates more/different code, etc. Still a bit stumped on it, but hey. I fixed it.


### Exposing APIs
- system settings (volume, PAL/NTSC, etc)
- joypad buttons
  > side node added player 2 support after studying the [nesdev page](https://wiki.nesdev.com/w/index.php/Controller_Reading) on reading controller inputs. The trick was a certain memory address was not being written when it should have been.

### Savestates
- compressing via lzw


---

Though you can use nES6 today, the modernization/rewriting of WebNES to nES6 is an ongoing project.