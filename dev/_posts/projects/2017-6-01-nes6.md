---
layout: dev-post
title: nES6
permalink: /dev/nes6/
blog: dev
project: nes6
isProject: true
tech:
  - javascript
thumbnail: http://i.imgur.com/9bRFZuD.jpg
github: https://github.com/andymikulski/nes6
---

# NES Emulator Written in ES6

Existing NES emulators (for the web) attempt to be an all-in-one solution. As a result, UI and emulator code is tightly coupled together, and you can't do much with the package outside of using it on its own as a standalone emulator.

nES6 was created to allow programmatic control of each piece of the emulator. For example, if you drop an nES6 instance into a page, you'll get a blank canvas and that's it. It's then up to you how the emulator is fed ROMs, controller input, etc, using the exposed API from nES6.

A real-world use case is [MultiNES](/MultiNES), where inputs are synced across users' emulators based on remote joypad input.

---

## Introduction

Some time ago, I had an idea on how I could possibly create a multiplayer NES experience for the web. The idea was pretty basic: simply run the inputs from one player to the other! Packed with my bit of [socket.io](https://socket.io/) from that one chat demo I had put together in a few minutes, I was sure I could get this thing working. And I did! But it was a long path to get there.

Initially, I hoped to simply use someone else's emulator, as I was keen on testing out my multiplayer idea, and not necessarily re-emulating the wheel. Unfortunately, there wasn't an emulator available that offered an API for programattic control. Most packages/library offered "full-scale" solutions, in that they attempted to be an entire application. For instance, [WebNES](https://peteward44.github.io/WebNES/index_app.html) offers UI elements for loading ROMs, adjusting volume, etc.

### Good Artists Copy, Great Artists Fork

I will say here and now: my work stands on the shoulders of giants. Without finding Pete Ward's [WebNES repo](https://github.com/peteward44/webnes), my project would not have gone anywhere. WebNES offered support for most games, WebGL + shader capability, and save states could painlessly be imported/exported. Having never worked with an emulator before, it was also easy to approach the pure javascript codebase. I forked WebNES, and with the intention of a complete overhaul into 'modern' javascript, renamed the project [nES6](https://github.com/andymikulski/nES6/).

<img src="https://imgur.com/NY8MPU7.png" style="max-height: 500px" title="River City Ransom on WebNES" />
<label>WebNES offers support for WebGL shaders which is a nice bonus! Here, a curved CRT filter is applied.</label>

### Additional Features

After converting the codebase to ES6, I added a handful of features, which primarily stemmed from needs while developing MultiNES. Features included:

**Plugin System**
Developers can create their own plugins, or use one of the built-in plugins:
 - `bindGamepad` maps USB controller inputs to nES6
 - `bindKeyboard` provides sensible default keyboard controls, as well as a modifiable keymap.
 - `dragDropLoader` provides functionality to let the user load a local ROM file via drag-n-dropping the file into the emulator. Great for single-player applications.

**Headless Rendering**
Due to the model used for networking, a key requirement for MultiNES's success was the ability to run a copy of the emulator on a Node server. For that, nES6 needed a mode of rendering which would produce identical gamestates without actually rendering any of the graphics to the screen.



# Screenshots

<div class="screenshots">
	<div>
		<video src="https://i.imgur.com/sITDVfI.mp4" loop controls></video>
		<label>Mega Man title screen glitch art. A result of attempting to skip certain PPU instructions.</label>
	</div>
	<div>
		<video src="https://i.imgur.com/63VVbmz.mp4" loop controls></video>
		<label>More skipped instructions.</label>
	</div>
	<div>
		<img src="http://i.imgur.com/2CEXB1E.jpg" />
		<label>Result of attempting to cache lookup values to increase performance.</label>
	</div>
</div>
